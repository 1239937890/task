<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>

        //   let log = console.log;
        //     function A(){
        //         this.x = 8;
        //     }
        //     function B(){
        //     }
        //     B.prototype = new A();
        //     function C(){
        //     }
        //     C.prototype = new B()
        //     function D(){
        //     }
        //     D.prototype = new C()
        //     function E(){
        //         this.x = 1;
        //     }
        //     E.prototype = new D()
        //     let a = new E();
        //     log(a.x)
        //     log(a.__proto__)
        //     log(E.prototype)
//     //   let xx = {

//     //   }
//     //   console.log(xx)
        function Dongwu(name) //基类构造函数
        {
            this.name = name; //设置对象属性
            // this.behavior = function(){
            //     console.log(this.name);
            // }
        }
        Dongwu.prototype.behavior = function () //给基类构造函数的prototype添加behavior方法
        {
            console.log("this is a " + this.name);
        }
        var Dog = new Dongwu("dog"); //创建Dog对象
        console.log(Dog)
        var Cat = new Dongwu("cat"); //创建Cat对象
        Dog.behavior(); //通过Dog对象直接调用behavior方法
        Cat.behavior(); // "this is a cat"
        // 可以从程序运行结果看出，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。
//  console.log(Dongwu.prototype.isPrototypeOf(Dog))

        // console.log(Object.getPrototypeOf(Dog))
        // console.log(Dongwu.prototype)
        
    </script>
</body>

</html>